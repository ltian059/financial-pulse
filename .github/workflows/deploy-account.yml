name: Deploy Account Service

on:
  push:
    branches: [ master ]
    paths:
      - 'fp-account/**'
      - 'fp-common/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'account-dev'
        type: choice
        options:
          - account-dev
          - account-test
          - account-prod

jobs:
  validate-env:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML

      - name: Validate environment variables
        run: |
          python scripts/validate-env-vars.py account

  build:
    runs-on: ubuntu-latest
    needs: [validate-env]
    outputs:
      jar-name: ${{steps.build.outputs.jar-name}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Build with Maven
        id: build
        run: |
          # First install the parent POM
          mvn clean install -N
          # Then install fp-common
          mvn clean install -pl fp-common -DskipTests
          # Finally build fp-account
          mvn clean package -pl fp-account -DskipTests
          JAR_NAME=$(ls fp-account/target/fp-account-*.jar | head -1 | xargs basename)
          echo "jar-name=$JAR_NAME" >> $GITHUB_OUTPUT
          echo "Built JAR: $JAR_NAME"

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: account-service-jar
          path: fp-account/target/fp-account-*.jar
          retention-days: 30

  deploy:
    runs-on: ubuntu-latest
    needs: [ build ]
    # The Environment currently deploying to
    environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: account-service-jar
          path: ./

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'

      - name: Install boto3
        run: pip install boto3

      - name: Create temporary SSM endpoints
        run: |
          python scripts/manage_stack.py create fp-ssm-endpoints ./cloudformation/01-foundation/vpc-ssm-endpoints.yml

      - name: Wait for SSM Agent to reconnect
        run: |
          echo "Waiting for 60 seconds to allow the SSM Agent on the EC2 instance to self-heal and reconnect to the new endpoints..."
          sleep 60

      - name: Clear DNS cache on EC2 instance
        id: flush-dns
        run: |
            INSTANCE_ID="${{ vars.EC2_ACCOUNT_INSTANCE_ID }}"
            echo "Sending command to clear DNS cache on instance $INSTANCE_ID..."
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=['sudo systemd-resolve --flush-caches', 'echo DNS cache flushed successfully']" \
              --query "Command.CommandId" --output text)
            
            echo "Waiting for DNS cache flush command ($COMMAND_ID) to complete..."
            
            for i in {1..10}; do
              STATUS=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'Status' --output text 2>/dev/null || echo "InProgress")
            
              echo "Status: $STATUS (attempt $i/10)"
            
              if [ "$STATUS" = "Success" ]; then
                echo "✅ DNS cache flushed successfully!"
                aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardOutputContent' --output text
                exit 0
              elif [ "$STATUS" = "Failed" ]; then
                echo "❌ Failed to flush DNS cache!"
                aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$INSTANCE_ID" --query 'StandardErrorContent' --output text
                exit 1
              fi
              sleep 5
            done
            
            echo "❌ Timed out waiting for DNS cache flush command."
            exit 1
#
#      - name: Setup SSH key
#        run: |
#          echo "${{ secrets.EC2_SSH_KEY }}" > /tmp/fp-keypair.pem
#          chmod 600 /tmp/fp-keypair.pem

      - name: Determine Spring Profile
        id: profile
        run: |
          ENV_NAME="${{ github.event.inputs.environment || 'account-dev' }}"
          SPRING_PROFILE=${ENV_NAME#*-} # Remove 'account-' prefix
          echo "Environment: $ENV_NAME"
          echo "Spring Profile: $SPRING_PROFILE"
          echo "profile=$SPRING_PROFILE" >> $GITHUB_OUTPUT

      - name: Create environment configuration
        run: |
          cat > .env << 'EOF'
          # Application Configuration
          SPRING_PROFILES_ACTIVE=${{ steps.profile.outputs.profile }}
          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          # AWS Configuration
          
          AWS_REGION=${{ vars.AWS_REGION }}
          # Server port
          SERVER_PORT=8080
          # DynamoDB configuration
          DYNAMODB_TABLE_PREFIX=${{ vars.DYNAMODB_TABLE_PREFIX }}
          DYNAMODB_TABLE_SUFFIX=${{ vars.DYNAMODB_TABLE_SUFFIX }}
          # SQS Configuration
          SQS_EMAIL_QUEUE_URL=${{ vars.SQS_EMAIL_QUEUE_URL }}
          SQS_FOLLOWER_NOTIFICATION_QUEUE_URL=${{ vars.SQS_FOLLOWER_NOTIFICATION_QUEUE_URL }}
          SQS_DEAD_LETTER_QUEUE_URL=${{ vars.SQS_DEAD_LETTER_QUEUE_URL }}
          
          AWS_SQS_ENABLED=true
          # SES Configuration
          AWS_SES_FROM_EMAIL=${{ secrets.AWS_SES_FROM_EMAIL }}
          EOF

          echo "Environment configuration created"

      - name: Set up start script
        run: |
          cat > start.sh << 'EOF'
          #!/bin/bash
          
          # start.sh - Financial Pulse Account Service Startup Script
          # Place this file at /opt/app/start.sh on EC2 instance
          cd /opt/app
        
          # Colors for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m'
        
          log_info() {
            echo -e "${GREEN}[INFO]${NC} $1"
          }
        
          log_warning() {
            echo -e "${YELLOW}[WARNING]${NC} $1"
          }
        
          log_error() {
            echo -e "${RED}[ERROR]${NC} $1"
          }
        
          # Load environment variables from .env file
          load_environment() {
            if [ -f .env ]; then
            log_info "Loading environment variables from .env file..."
            # Export variables while filtering out comments and empty lines
            export $(cat .env | grep -v '^#' | grep -v '^$' | xargs)
            log_info "Environment variables loaded successfully"
            else
            log_error ".env file not found!"
            log_error "Please ensure the deployment process has created the .env file"
            exit 1
            fi
          }
        
          # Validate critical configuration
          validate_configuration() {
            log_info "Validating application configuration..."
          
            # Check JWT Secret
            if [ -z "$JWT_SECRET" ]; then
            log_error "JWT_SECRET is not set"
            exit 1
            fi
          
            if [ ${#JWT_SECRET} -lt 10 ]; then
            log_error "JWT_SECRET is too short (minimum 10 characters)"
            exit 1
            fi
          
            # Check SQS Configuration (if enabled)
            if [ "$AWS_SQS_ENABLED" = "true" ]; then
              if [ -z "$SQS_EMAIL_QUEUE_URL" ]; then
                log_error "SQS_EMAIL_QUEUE_URL is not set but SQS is enabled"
                exit 1
              fi
              log_info "SQS configuration validated"
            fi
          
            log_info "Configuration validation completed"
          }
        
          # Check if JAR file exists
          check_jar_file() {
            if [ ! -f "fp-account.jar" ]; then
            log_error "fp-account.jar not found!"
            log_error "Please deploy the application JAR file first"
            exit 1
            fi
          
          log_info "JAR file found: fp-account.jar"
          }
        
          # Start the application
          start_application() {
            log_info "Starting Financial Pulse Account Service..."
            log_info "Environment: $SPRING_PROFILES_ACTIVE"
            log_info "AWS Region: $AWS_REGION"
            log_info "Server Port: $SERVER_PORT"
            log_info "JWT Secret configured: ${#JWT_SECRET} characters"
          
            # Set JVM options
            JAVA_OPTS="-Xmx512m -Xms256m"
            JAVA_OPTS="$JAVA_OPTS -Djava.security.egd=file:/dev/./urandom"
            # Create startup command
            local cmd="java $JAVA_OPTS -jar fp-account.jar"
            LOG_FILE="app.log"
            PID_FILE="app.pid"
            # Start in background and redirect Java output to log file
            nohup $cmd >> "$LOG_FILE" 2>&1 &
            local app_pid=$!
            # Save PID to file
            echo "$app_pid" > "$PID_FILE"
          log_info "Application started with PID: $app_pid"
          log_info "PID saved to: $PID_FILE"
          }
        
          # Main execution
          main() {
            echo "========================================"
            echo "Financial Pulse Account Service Startup"
            echo "========================================"
          
            load_environment
            validate_configuration
            check_jar_file
            start_application
          }
          # Handle script interruption
          cleanup() {
            log_warning "Application startup interrupted"
            exit 1
          }
          trap cleanup INT TERM
        
          # Run the main function
          main
          EOF


      - name: Set up stop script
        run: |
          cat > stop.sh << 'EOF'
          #!/bin/bash
          cd /opt/app

          if [ -f app.pid ]; then
              echo "Terminating (PID: $(cat app.pid))..."
              kill $(cat app.pid)
              rm -f app.pid
              echo "Application terminated"
          else
              echo "No application found running."
              # Kill any existing java processes (fallback)
              pkill -f "fp-account.jar" 2>/dev/null || true
          fi
          EOF
          
          # Make scripts executable
          chmod +x start.sh stop.sh

      - name: Deploy via S3 and Systems Manager
        run: |
          BUCKET_NAME="financial-pulse-deployment-artifacts"
          S3_KEY="account/fp-account-${{ github.sha }}.jar"
          INSTANCE_ID="${{ vars.EC2_ACCOUNT_INSTANCE_ID }}"
          
          echo "Uploading JAR to S3..."
          aws s3 cp ${{ needs.build.outputs.jar-name }} \
            s3://$BUCKET_NAME/$S3_KEY
          
          echo "Uploading configuration files to S3..."
          aws s3 cp .env s3://$BUCKET_NAME/account/.env-${{ github.sha }}
          aws s3 cp start.sh s3://$BUCKET_NAME/account/start.sh
          aws s3 cp stop.sh s3://$BUCKET_NAME/account/stop.sh
          
          echo "Deploying via Systems Manager..."
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'echo \"=== Financial Pulse Deployment Starting ===\"',
              'cd /opt/app',
              'echo \"Downloading from S3...\"',
              'aws s3 cp s3://$BUCKET_NAME/$S3_KEY ./fp-account.jar',
              'aws s3 cp s3://$BUCKET_NAME/account/.env-${{ github.sha }} ./.env',
              'aws s3 cp s3://$BUCKET_NAME/account/start.sh ./start.sh',
              'aws s3 cp s3://$BUCKET_NAME/account/stop.sh ./stop.sh',
              'echo \"Setting permissions...\"',
              'chmod +x start.sh stop.sh',
              'chmod 644 .env fp-account.jar',
              'echo \"Stopping existing service...\"',
              './stop.sh || true',
              'echo \"Starting new service...\"',
              './start.sh',
              'sleep 5',
              'echo \"Checking service status...\"',
              'if pgrep -f \"fp-account.jar\"; then echo \"✅ Service started successfully\"; else echo \"❌ Service failed to start\"; exit 1; fi',
              'echo \"=== Deployment completed successfully ===\"'
            ]" \
            --output text --query 'Command.CommandId')
          
          echo "Command ID: $COMMAND_ID"
          echo "Waiting for command execution..."
          
          # 等待命令执行完成
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id $INSTANCE_ID \
              --query 'Status' --output text 2>/dev/null || echo "InProgress")
            
            echo "Status: $STATUS (attempt $i/30)"
            
            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deployment successful!"
              echo "=== Command Output ==="
              aws ssm get-command-invocation \
                --command-id $COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --query 'StandardOutputContent' --output text
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "❌ Deployment failed!"
              echo "=== Error Output ==="
              aws ssm get-command-invocation \
                --command-id $COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --query 'StandardErrorContent' --output text
              exit 1
            fi
            
            sleep 10
          done

      - name: Delete temporary SSM endpoints
        if: success()
        run: |
          python scripts/manage_stack.py delete fp-ssm-endpoints